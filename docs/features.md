## 服务器功能
* 用户管理模块：
    * 注册与登录：用户注册、登录功能，支持玩家的身份认证，可以使用JWT进行令牌验证。（steam SDK？）
    * 玩家状态管理：管理玩家的月光值、卡牌状态、地图进度等。
    * 登录认证
        * 可以使用第三方现成的登录验证框架（CasBin、Satoken等），对请求进行身份验证
        * 可配置的认证白名单，对于某些不需要认证的接口或路径，允许直接访问
        * 可配置的黑名单，对于某些异常的用户，直接进行封禁处理（可选）
        * JWT认证：非常适合无状态的API设计，支持高并发的用户请求处理。可以考虑加上Token的刷新机制（Refresh Token），保证用户登录状态不会因为长时间未活动而被强制注销。
        * OAuth2.0与第三方认证：如果你的游戏支持第三方登录（如Steam等），OAuth2.0是一个理想的选择，可以配合JWT使用，实现轻量级的认证和授权。
    * 权限认证（高级）
        * 根据用户的角色和权限，对请求进行授权检查，确保只有具有相应权限的用户能够访问特定的服务或接口。
        * 支持正则表达模式的权限匹配
        * 支持动态更新用户权限信息，当用户权限发生变化时，权限校验能够实时生效。
* 游戏引擎模块：
    * 卡牌机制引擎：根据游戏灵感中的卡牌机制（如“同相”、“反相”、“月相周期”）计算并更新玩家的状态。
    * 地图与格子管理：管理玩家的竞速地图，计算玩家的进度、归属权、月光消耗等。
    * 事件机制：实现全局事件，如“月光风暴”、“干扰区”等，根据游戏进度动态触发，并通知前端。
    * 卡牌机制与事件系统：建议尽早开始对卡牌机制、地图管理、事件机制的业务逻辑建模，并使用单元测试来验证各个模块的正确性。可以使用类似状态机（State Machine）的设计模式来管理不同的游戏状态。
    * 并发处理：在高并发的环境下，可能需要使用类似Redis的分布式锁来同步玩家的游戏状态，避免并发修改引发数据不一致。
* 游戏存档与重启：
    * 保存游戏的进度和玩家状态，支持断线重连和游戏重启。
    * 存储玩家的卡牌、月光进度、地图状态等数据。
    * 高可用存档服务：存档功能需要非常高的可用性，建议使用分布式存储（如Ceph或MinIO）来存储玩家的游戏进度，支持断点续传和快速重启。
* 推送与通知：
    * 后端通过WebSocket推送实时游戏状态更新给前端。
    * Push通知与消息队列的结合：WebSocket可以作为主要的实时推送手段，但对于离线用户的推送通知，考虑结合消息队列（如NATS或RabbitMQ）来管理通知的发送，确保在不同的网络环境下也能及时送达。
* 日志记录与监控
  * 对服务的运行状态和请求处理过程进行详细的日志记录，方便故障排查和性能分析。
  * 提供实时监控功能，能够及时发现和解决系统中的问题。
* 容错机制
  * 该服务应具备一定的容错能力，当出现部分下游服务不可用或网络故障时，能够自动切换到备用服务或进行降级处理。
  * 保证下游在异常情况下，系统的整体可用性不会受太大影响，且核心服务可用。
  * 服务应该具有一定的流量兜底措施，在服务流量激增时，应该给予一定的限流措施。
